---
layout: post
title: "Spring Boot의 Bean 등록 방식과 웹 서버/WAS 구조 이해"
categories: [Spring]
tags: [Spring, SpringBoot, Bean, IoC, DI, WebServer, Was, Tomcat]
---

Spring Boot로 애플리케이션을 개발하다 보면
자주 마주하게 되는 개념 중 하나가 바로 Bean 등록 방식이다.
`@Service`, `@Component`를 붙이면 자동으로 등록되기도 하고,
어떤 경우에는 `@Configuration`과 `@Bean`을 사용해 직접 빈을 정의하기도 한다.
겉보기에는 단순히 “등록 방법의 차이”처럼 보이지만,
실제로는 애플리케이션의 구조, 의존성 관리 방식, 확장성과 깊이 연관되어 있다.

이 글에서는 Spring Boot에서
사용되는 다양한 Bean 등록 방법을 정리하고,
각 방식의 장단점과 선택 기준을 함께 살펴본다.

---

## 1. Spring Boot에서 사용되는 다양한 Bean 등록 방법

### 1-1) Bean 등록 방법

Spring Boot에서는 Bean을 등록하는 방법으로
크게 `자동 등록` 방식과 `수동 등록` 방식, 그리고 `조건부 등록` 방식을 제공한다.

가장 대표적인 방식은 컴포넌트 스캔 기반 자동 등록이다.
`@Component`, `@Service`, `@Repository`, `@Controller` 등의
애너테이션을 클래스에 붙이면, Spring이 클래스패스를 스캔하여 Bean으로 자동 등록한다. 
이 방식은 코드가 간결하고 개발 속도가 빠르며,
Spring Boot의 기본 철학인 “관례에 의한 설정”에 가장 잘 부합한다.

반면, `@Configuration`과 `@Bean`을 활용한 수동 등록 방식도 자주 사용된다.
이 방식은 설정 클래스에서 객체를 직접 생성하여 Bean으로 등록하며,
어떤 구현체를 사용할지 명확하게 제어할 수 있다는 장점이 있다.
구현체 교체가 필요한 경우나 외부 라이브러리를 Bean으로 등록해야 할 때 특히 유용하다.

또한 Spring Boot는 조건부 Bean 등록 방식을 제공한다.
`@Profile`, `@ConditionalOnProperty`, `@ConditionalOnMissingBean`
등의 애너테이션을 활용하면 실행 환경이나 설정 값에 따라 Bean 등록 여부를 제어할 수 있다.
이는 Spring Boot의 **자동 설정(Auto Configuration)**의 핵심 메커니즘이다.

### 1-2) Bean 등록 방식별 장단점 비교

컴포넌트 스캔 기반 자동 등록은 **간결성과 생산성**이 가장 큰 장점이다.
애너테이션만으로 Bean을 등록할 수 있어 코드량이 적고 구조가 직관적이다.
하지만 구현체가 여러 개인 경우 어떤 Bean이 주입되는지 명확하지 않아,
`@Primary`나 `@Qualifier`와 같은 추가 설정이 필요할 수 있다.

`@Bean`을 활용한 수동 등록 방식은 **명확성과 제어력**이 강점이다.
Bean 생성 과정과 의존성 구성이 설정 클래스에 드러나기 때문에 
구조를 이해하기 쉽고, 구현체 교체도 설정 변경만으로 가능하다. 
다만 설정 코드가 늘어나면서 보일러플레이트가 많아질 수 있다는 단점이 있다.

조건부 Bean 등록 방식은 **환경 대응력이 뛰어나다**는 장점이 있다.
개발/운영/테스트 환경에 따라 다른 Bean 구성을 자동으로 적용할 수 있지만,
조건이 복잡해질수록 “왜 이 Bean이 등록되지 않았는지”를 추적하기 어려워질 수 있다.

결국 Bean 등록 방식에는 절대적인 정답이 있는 것이 아니라,
**프로젝트의 규모와 요구사항에 따라 적절한 방식을 선택하는 것**이 중요하다.

---

## 2. 웹 서버(Web Server)와 WAS(Web Application Server)의 차이

Spring Boot 애플리케이션의 실행 구조를 
이해하기 위해서는 웹 서버와 WAS의 역할 차이를 이해해야 한다.

`Web Server`는 HTML, CSS, JavaScript 같은 **정적 리소스를 제공하는 역할에 집중**한다. 
또한 요청을 적절한 서버로 전달하는 리버스 프록시 역할을 수행한다. 
대표적인 예로는 `Nginx`와 `Apache HTTP Server`가 있다.

반면 `WAS(Web Application Server)`는 웹 서버의 기능을 포함하면서,
동적인 애플리케이션 로직을 실행한다. 서버 사이드 코드를 실행하고
데이터베이스와 연동하여 요청에 따라 다른 응답을 생성한다.
Java 환경에서는 **Servlet 컨테이너를 포함한 서버를 WAS**라고 부른다.

실제 서비스 환경에서는 두 서버를 분리해 웹 서버 + WAS 구조로 구성하는 경우가 일반적이다.

### 2-1) Spring Boot의 내장 톰캣은 어디에 해당할까?

Spring Boot는 별도의 서버 설치 없이 애플리케이션을
실행할 수 있도록 내장 톰캣(Embedded Tomcat) 을 제공한다. 
이 내장 톰캣은 단순한 웹 서버가 아니라, `WAS(Web Application Server)` 에 해당한다.

내장 톰캣은 HTTP 요청을 직접 수신하고, Servlet 컨테이너 역할을 수행하며,
Spring MVC 컨트롤러와 비즈니스 로직을 실행한다. 
즉, Spring Boot 애플리케이션은 **Spring + 내장 톰캣(WAS) 구조**로 동작한다.

이 구조 덕분에 개발자는 별도의 톰캣 설치나 WAR 배포 없이,
JAR 파일 하나로 서버 애플리케이션을 실행할 수 있다.

---

### 마무리

Spring Boot는 Bean 관리 방식부터 애플리케이션 실행 환경까지 복잡한 설정을 단순화한다.
Bean 등록 방식을 통해 객체의 생성과 의존성을 관리하고,
내장 WAS를 통해 서버 환경 설정 부담을 줄임으로써 개발자가 비즈니스 로직에 집중할 수 있도록 돕는다.

Bean 등록 방식과 웹 서버/WAS의 역할을 함께 이해하면,
Spring Boot 애플리케이션이 어떤 구조 위에서 어떻게 동작하는지를 더 명확하게 이해할 수 있다.

Spring Boot는 유연한 Bean 등록 방식과 내장 WAS 구조를 통해,
**설정은 단순하게** 유지하면서도 **확장성과 구조적 명확성**을 제공한다.
